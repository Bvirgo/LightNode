{"name":"LightNode","tagline":"Micro RPC/REST Framework built on OWIN","body":"LightNode\r\n=========\r\nLightNode is Micro RPC/REST Framework built on OWIN provides both server and client. Server is lightweight and performant implementation. Client is code generation(T4) based auto generated RPC Client based on HttpClient, of course everything return Task. And client code generation will provide for Unity3D and TypeScript. \r\n\r\nInstallation\r\n---\r\nbinary from NuGet, [LightNode.Server](https://nuget.org/packages/LightNode.Server/)\r\n\r\n```\r\nPM> Install-Package LightNode.Server\r\n```\r\n\r\nand Client is [LightNode.Client.PCL.T4](https://nuget.org/packages/LightNode.Client.PCL.T4/)\r\n\r\n```\r\nPM> Install-Package LightNode.Client.PCL.T4\r\n```\r\nand ContentFormatters(for JsonNet, ProtoBuf, MsgPack)\r\n```\r\nPM> Install-Package LightNode.Formatter.JsonNet\r\nPM> Install-Package LightNode.Formatter.ProtoBuf\r\nPM> Install-Package LightNode.Formatter.MsgPack\r\n```\r\n\r\nLightweight Server\r\n---\r\nServer implementation is very easy, built up Owin and implements `LightNodeContract`.\r\n\r\n```csharp\r\n// Owin Code\r\npublic class Startup\r\n{\r\n    public void Configuration(Owin.IAppBuilder app)\r\n    {\r\n        // global configuration, select your primary/secondary formatters(JsonNet/ProtoBuf/MsgPack/Xml/etc...)\r\n        app.UseLightNode(new LightNodeOptions(\r\n            AcceptVerbs.Get | AcceptVerbs.Post, \r\n            new JavaScriptContentTypeFormatter()));\r\n    }\r\n}\r\n\r\n// implement LightNodeContract, all public methods become API.\r\n// You can access {ClassName}/{MethodName}\r\n// Ex. http://localhost/My/Echo?x=test\r\npublic class My : LightNodeContract\r\n{\r\n    // return value is response body serialized by ContentTypeFormatter.    \r\n    public string Echo(string x)\r\n    {\r\n        return x;\r\n    }\r\n\r\n    // support async! return type allows void, T, Task and Task<T>.\r\n    // parameter supports array, nullable and optional parameter.\r\n    public Task<int> Sum(int x, int? y, int z = 1000)\r\n    {\r\n        return Task.Run(() => x + y.Value + z);\r\n    }\r\n}\r\n```\r\n \r\nServer API rule is very simple.\r\n\r\n> Parameter model bindings supports only basic pattern, can't use complex type. allow types are \"string, DateTime, DateTimeOffset, Boolean, Decimal, Char, TimeSpan, Int16, Int32, Int64, UInt16, UInt32, UInt64, Single, Double, SByte, Byte and each Nullable types and array(except byte[]. If you want to use byte[], use Base64 string instead of byte[])\r\n\r\nReturn type allows all serializable(ContentFormatter support) type.\r\n\r\nFilter\r\n---\r\nLightNode supports filter. The implementation is like middleware pipeline.\r\n\r\n![lightnode_performance](https://f.cloud.github.com/assets/46207/1902207/3dbe3012-7c6f-11e3-8d39-7e442e92b970.jpg)\r\n\r\n```csharp\r\npublic class SampleFilterAttribute : LightNodeFilterAttribute\r\n{\r\n    public override async Task Invoke(OperationContext operationContext, Func<Task> next)\r\n    {\r\n        try\r\n        {\r\n            // OnBeforeAction\r\n\r\n            await next(); // next filter or operation handler\r\n\r\n            // OnAfterAction\r\n        }\r\n        catch\r\n        {\r\n            // OnExeception\r\n        }\r\n        finally\r\n        {\r\n            // OnFinally\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFilter can be attached contract(class), operation(method) and global. Execution pipeline is formed is sorted by Order all specified. Range is -int.MaxValue to int.MaxValue. Default Order of all filters is int.MaxValue.\r\n\r\nDifference between Middleware and Filter is who knows operation context. Filter is located after the parameter binding. Therefore, it is possible check attributes(`operationContext.IsAttributeDefined`, `operationContext.GetAttributes`).\r\n\r\nControl StatusCode\r\n---\r\nThe default status code, can't find operation returns 404, failed operation returns 500, success and has value returns 200, success and no value returns 204. If returns arbitrary status code, throw ReturnStatusCodeException.\r\n\r\n```csharp\r\nthrow new ReturnStatusCodeException(System.Net.HttpStatusCode.Unauthorized);\r\n```\r\n\r\nAuthenticate, Routing, Session, etc...\r\n---\r\nYou can use other owin middleware. For example, Auth:Microsoft.Owin.Security.*, Session:[Owin.RedisSession](https://github.com/neuecc/Owin.RedisSession/), Context:[OwinRequestScopeContext](https://github.com/neuecc/OwinRequestScopeContext), etc...\r\n\r\nRouting and versioning example.\r\n```csharp\r\n// Conditional Use\r\napp.MapWhen(x => x.Request.Path.Value.StartsWith(\"/v1/\"), ap =>\r\n{\r\n   // Trim Version Path\r\n   ap.Use((context, next) =>\r\n   {\r\n        context.Request.Path = new Microsoft.Owin.PathString(\r\n            Regex.Replace(context.Request.Path.Value, @\"^/v[1-9]/\", \"/\"));\r\n        return next();\r\n   });\r\n \r\n    // use v1 assembly\r\n    ap.UseLightNode(new LightNodeOptions(AcceptVerbs.Post, new JsonNetContentFormatter()),\r\n        typeof(v1Contract).Assembly);\r\n});\r\n \r\napp.MapWhen(x => x.Request.Path.Value.StartsWith(\"/v2/\"), ap =>\r\n{\r\n   // copy and paste:)\r\n   ap.Use((context, next) =>\r\n   {\r\n        context.Request.Path = new Microsoft.Owin.PathString(\r\n            Regex.Replace(context.Request.Path.Value, @\"^/v[1-9]/\", \"/\"));\r\n        return next();\r\n   });\r\n   \r\n   // use v2 assembly\r\n   ap.UseLightNode(new LightNodeOptions(AcceptVerbs.Post, new JsonNetContentFormatter()),\r\n    typeof(v2Contract).Assembly);\r\n});\r\n```\r\nComposability is owin's nice feature.\r\n\r\nLightweight Client\r\n--- \r\nImplementation of the REST API is often painful. LightNode solves by T4 code generation.\r\n\r\n```csharp\r\n// Open .tt file and configure four steps.\r\n\r\n<#@ assembly name=\"$(SolutionDir)\\Performance\\LightNode.Performance\\bin\\LightNode.Server.dll\" #>\r\n<#@ assembly name=\"$(SolutionDir)\\Performance\\LightNode.Performance\\bin\\LightNode.Performance.dll\" #>\r\n<#\r\n    // ------------- T4 Configuration ------------- //\r\n    \r\n    // 1. Set LightNodeContract assemblies(and all dependency) path to above #@ assembly name # directive\r\n\r\n    // 2. Set Namespace & ClientName & Namespace\r\n    var clientName = \"LightNodeClient\";\r\n    var namespaceName = \"LightNode.Client\";\r\n\r\n    // 3. Set DefaultContentFormatter Construct String\r\n    var defaultContentFormatter = \"new LightNode.Formatter.XmlContentFormatter()\";\r\n\r\n    // 4. Set Additional using Namespace\r\n    var usingNamespaces = new [] {\"System.Linq\"};\r\n\r\n    // 5. Set append \"Async\" suffix to method name(ex: CalcAsync or Calc)\r\n    var addAsyncSuffix = true;\r\n\r\n    // ----------End T4 Configuration ------------- //\r\n```\r\n\r\n```csharp\r\n// generated code is like RPC Style.\r\n// {ClassName}.{MethodName}({Parameters}) \r\n\r\nvar client = new LightNodeClient(\"http://localhost\");\r\nawait client.Me.EchoAsync(\"test\");\r\nvar sum = await client.Me.SumAsync(1, 10, 100);\r\n```\r\n\r\nClient is very simple, too.\r\n\r\n> Currently provides only for Portable Class Library. But we plan for Unity3D and TypeScript.\r\n\r\nLanguage Interoperability\r\n---\r\nLightNode is like RPC but REST. Public API follows a simple rule. Address is `{ClassName}/{MethodName}`, and it's case insensitive. GET parameter use QueryString. POST parameter use x-www-form-urlencoded. Response type follows configured ContentFormatter. Receiver can select response type use url extension(.xml, .json etc...) or Accept header.\r\n\r\nPerformance\r\n---\r\nLightNode is fastest framework.\r\n\r\n![lightnode_performance](https://f.cloud.github.com/assets/46207/1902439/a0a19c5c-7c72-11e3-9bea-244ac00dcd87.jpg)\r\n\r\nPerformance source code is in [LightNode/Performance](https://github.com/neuecc/LightNode/tree/master/Performance). Enviroment is \"Windows 8.1/CPU Core i7-3770K(3.5GHz)/Memory 32GB\" and disabled firewall and windows defender. Orange and Green bar is hosted on IIS(System.Web). LightNode(Green bar)'s performance is nearly raw handler. Gray bar is reference, LightNode on [Helios - Microsoft.Owin.Host.IIS](http://www.nuget.org/packages/Microsoft.Owin.Host.IIS/) gots extremely performance. \r\n\r\nReleaseNote\r\n---\r\n0.2.0 - 2014-01-14\r\n* Add Filter System\r\n* Enum Binding Performance Improvement\r\n* Strict parse for Enum\r\n* Parameter String disallows null at default\r\n* IContentFormatter needs Encoding\r\n* IContentFormatter.Ext can add multiple ext by \"|\" separater\r\n* Fixed T4 ClientCode generation\r\n* Return 204 when operation is void or Task\r\n* Return Arbitrary StatusCode that throws ReturnStatusCodeException\r\n* Add IgnoreOperationAttribute\r\n\r\n0.1.1 - 2013-12-23  \r\n* First Release","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}