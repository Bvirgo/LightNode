{"name":"LightNode","tagline":"Micro RPC/REST Framework built on OWIN","body":"LightNode\r\n=========\r\nLightNode is a Micro RPC/REST Framework built on OWIN. LightNode is a good alternative to the ASP.NET Web API and Nancy if you make a simple API. It is like Ruby's [Grape](https://github.com/intridea/grape) framework. Implementation of the API is lightweight, powerful debugging supports with [Glimpse](http://getglimpse.com/), client code generation by T4 for PCL(HttpClient) and Unity3D.  \r\n\r\nInstallation\r\n---\r\nbinary from NuGet, [LightNode.Server](https://nuget.org/packages/LightNode.Server/)\r\n\r\n```\r\nPM> Install-Package LightNode.Server\r\n```\r\n\r\nImplement Server\r\n---\r\nServer implementation is very easy, built up Owin and implements `LightNodeContract`.\r\n\r\n```csharp\r\n// Owin Startup\r\npublic class Startup\r\n{\r\n    public void Configuration(IAppBuilder app)\r\n    {\r\n        app.UseLightNode();\r\n    }\r\n}\r\n\r\n// implement LightNodeContract, all public methods become API.\r\n// You can access {ClassName}/{MethodName}\r\n// Ex. http://localhost/My/Echo?x=test\r\npublic class My : LightNodeContract\r\n{\r\n    // return value is response body serialized by ContentTypeFormatter(default is JSON).    \r\n    public string Echo(string x)\r\n    {\r\n        return x;\r\n    }\r\n\r\n    // support async! return type allows void, T, Task and Task<T>.\r\n    // parameter supports array, nullable and optional parameter.\r\n    public Task<int> Sum(int x, int? y, int z = 1000)\r\n    {\r\n        return Task.Run(() => x + y.Value + z);\r\n    }\r\n}\r\n```\r\n\r\nCompile, run, very quick! LightNode calls class as Contract, method as Operation.\r\n\r\n> Parameter model bindings supports only basic pattern, can't use complex type. allow types are \"string, DateTime, DateTimeOffset, Boolean, Decimal, Char, TimeSpan, Int16, Int32, Int64, UInt16, UInt32, UInt64, Single, Double, SByte, Byte, Enum and each Nullable types and array(except byte[]. If you want to use byte[], use Base64 string instead of byte[] or see [receive byte[] section](#receiveor-send-byte))\r\n\r\n> Return type allows all serializable(ContentFormatter support) type.\r\n\r\nFilter\r\n---\r\nLightNode supports filter. The implementation is like middleware pipeline.\r\n\r\n![lightnode_performance](https://f.cloud.github.com/assets/46207/1902207/3dbe3012-7c6f-11e3-8d39-7e442e92b970.jpg)\r\n\r\n```csharp\r\npublic class SampleFilterAttribute : LightNodeFilterAttribute\r\n{\r\n    public override async Task Invoke(OperationContext operationContext, Func<Task> next)\r\n    {\r\n        try\r\n        {\r\n            // OnBeforeAction\r\n\r\n            await next(); // next filter or operation handler\r\n\r\n            // OnAfterAction\r\n        }\r\n        catch\r\n        {\r\n            // OnExeception\r\n        }\r\n        finally\r\n        {\r\n            // OnFinally\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFilter can be attached contract(class), operation(method) and global. Execution pipeline is formed is sorted by Order all specified. Range is -int.MaxValue to int.MaxValue. Default Order of all filters is int.MaxValue.\r\n\r\nDifference between Middleware and Filter is who knows operation context. Filter is located after the parameter binding. Therefore, it is possible check attributes(`operationContext.IsAttributeDefined`, `operationContext.GetAttributes`).\r\n\r\nControl StatusCode\r\n---\r\nThe default status code, can't find operation returns 404, failed operation returns 500, success and has value returns 200, success and no value returns 204. If returns arbitrary status code, throw `ReturnStatusCodeException`.\r\n\r\n```csharp\r\nthrow new ReturnStatusCodeException(System.Net.HttpStatusCode.Unauthorized);\r\n```\r\n\r\nGlimpse plugin\r\n---\r\nLightNode fully supports [Glimpse](http://getglimpse.com/)! Currently Glimpse does not support Owin but if you host on `Microsoft.Owin.Host.SystemWeb` Glimpse works. You can download Glimpse plugin from NuGet. \r\n\r\n* PM> Install-Package [Glimpse.LightNode](https://nuget.org/packages/Glimpse.LightNode/)\r\n\r\nThere are configuration sample.\r\n\r\n```csharp\r\npublic void Configuration(Owin.IAppBuilder app)\r\n{\r\n    app.EnableGlimpse(); // This is Glimpse.LightNode's helper for enable Glimpse\r\n    app.MapWhen(x => !x.Request.Path.Value.StartsWith(\"/glimpse.axd\", StringComparison.OrdinalIgnoreCase), x =>\r\n    {\r\n        x.UseLightNode(new LightNodeOptions()\r\n        {\r\n            // for Glimpse Profiling\r\n            OperationCoordinatorFactory = new GlimpseProfilingOperationCoordinatorFactory()\r\n        });\r\n    });\r\n}\r\n```\r\n\r\nAccess glimpse.axd and Click Standalone Glimpse Launch Now! Click History window and Inspect. You can see Filter and Execution elapsed on Timeline tab.\r\n\r\n![](https://raw.githubusercontent.com/neuecc/LightNode/master/Img/glimpse_lightnode_timeline.jpg)\r\n\r\nCheck the LightNode tab, you can monitor everything. Parameters, Result, Exectuion Phase, Response, and LightNodeOptions.\r\n\r\n![](https://raw.githubusercontent.com/neuecc/LightNode/master/Img/lightnode_glimpse_infotab.jpg)\r\n\r\nIf encounts exception, LightNode tab shows exception on Result.\r\n\r\n![](https://raw.githubusercontent.com/neuecc/LightNode/master/Img/glimpse_infotab_exception.jpg)\r\n\r\nMy recommended glimpse configuration.\r\n\r\n```xml\r\n<!-- sometimes Glimpse rewrite response for display tab, but API no needs, set RuntimePolicy PersitResults -->\r\n<glimpse defaultRuntimePolicy=\"PersistResults\" endpointBaseUri=\"~/Glimpse.axd\">\r\n    <tabs>\r\n        <ignoredTypes>\r\n            <!-- no needs only Owin -->\r\n            <add type=\"Glimpse.AspNet.Tab.Cache, Glimpse.AspNet\" />\r\n            <add type=\"Glimpse.AspNet.Tab.Routes, Glimpse.AspNet\" />\r\n            <add type=\"Glimpse.AspNet.Tab.Session, Glimpse.AspNet\" />\r\n        </ignoredTypes>\r\n    </tabs>\r\n    <runtimePolicies>\r\n        <ignoredTypes>\r\n            <!-- If API's client no use cookie, ignore control cookie -->\r\n            <add type=\"Glimpse.Core.Policy.ControlCookiePolicy, Glimpse.Core\" />\r\n            <!-- for improvement LightNode debugging -->\r\n            <add type=\"Glimpse.Core.Policy.StatusCodePolicy, Glimpse.Core\" />\r\n            <!-- If not Ajax -->\r\n            <add type=\"Glimpse.Core.Policy.AjaxPolicy, Glimpse.Core\" />\r\n            <!-- If run on remote -->\r\n            <add type=\"Glimpse.AspNet.Policy.LocalPolicy, Glimpse.AspNet\" />\r\n        </ignoredTypes>\r\n    </runtimePolicies>\r\n</glimpse>\r\n```\r\n\r\nIgnore ControlCookiePolicy is very important. But we can't indistinguishable request. Glimpse handle group by cookie. You can add glimpseid cookie for example \r\n\r\n```csharp\r\nvar req = WebRequest.CreateHttp(\"http://localhost:41932/Member/Random?seed=13\");\r\n\r\nreq.CookieContainer = new CookieContainer();\r\nreq.CookieContainer.Add(new Uri(\"http://localhost:41932\"), new Cookie(\"glimpseid\", \"UserId:4\"));\r\n```\r\n![](https://raw.githubusercontent.com/neuecc/LightNode/master/Img/glimpse_history_clientgrouping.jpg)\r\n\r\nSwagger Integration\r\n---\r\nLightNode supports [Swagger](http://swagger.io/) for API Explorer(currently Swagger supports is experimental, only shows parameters).\r\n\r\n![](https://raw.githubusercontent.com/neuecc/LightNode/master/Img/swagger_support.jpg)\r\n\r\nMiddleware available in NuGet.\r\n\r\n* PM> Install-Package [LightNode.Swagger](https://nuget.org/packages/LightNode.Swagger/)\r\n\r\nSwagger-UI file is embedded in LightNode.Swagger. You can enable only `UseLightNodeSwagger`.\r\n\r\n```csharp\r\n// Currently LightNode.Swagger only supports POST so you needs AcceptVerbs.Post\r\napp.Map(\"/api\", builder =>\r\n{\r\n    builder.UseLightNode(new LightNodeOptions(AcceptVerbs.Get | AcceptVerbs.Post, new JilContentFormatter(), new GZipJilContentFormatter())\r\n    {\r\n        ParameterEnumAllowsFieldNameParse = true, // If you want to use enums human readable display on Swagger, set to true\r\n        ErrorHandlingPolicy = ErrorHandlingPolicy.ReturnInternalServerErrorIncludeErrorDetails,\r\n        OperationMissingHandlingPolicy = OperationMissingHandlingPolicy.ReturnErrorStatusCodeIncludeErrorDetails\r\n    });\r\n});\r\n\r\n// Mapping to swagger path\r\napp.Map(\"/swagger\", builder =>\r\n{\r\n    // If you want to additional info for Swagger, load xmlDoc file.\r\n    // LightNode.Swagger loads methods's summary, remarks, param for info.     \r\n    var xmlName = \"LightNode.Sample.GlimpseUse.xml\";\r\n    var xmlPath = System.AppDomain.CurrentDomain.BaseDirectory + \"\\\\bin\\\\\" + xmlName; // or HttpContext.Current.Server.MapPath(\"~/bin/\" + xmlName);\r\n\r\n    builder.UseLightNodeSwagger(new Swagger.SwaggerOptions(\"LightNodeSample\", \"/api\") // baseApi is LightNode's root\r\n    {\r\n        XmlDocumentPath = xmlPath,\r\n        IsEmitEnumAsString = true\r\n    });\r\n});\r\n```\r\n\r\nOkay, for example jump to `http://localhost:41932/Swagger/`, you can see all API info and Swagger specification json can download from `api-default.json`. If you host multiple LightNode engine, you can select target engine from `{engineID}.json`. `{engineID}` is from `ILightNodeOptions.ServerEngineId`.\r\n\r\nIf you can't run swagger on hosting IIS, maybe conflicts static file handling. Please remoe StaticFile handler and register OwinHttpHandler for all paths.\r\n\r\n```csharp\r\n<system.webServer>\r\n    <handlers>\r\n        <remove name=\"StaticFile\" />\r\n        <!-- If use with Glimpse, glimpse handler must be first -->\r\n        <add name=\"Glimpse\" path=\"glimpse.axd\" verb=\"GET\" type=\"Glimpse.AspNet.HttpHandler, Glimpse.AspNet\" preCondition=\"integratedMode\" />\r\n        <add name=\"OWIN\" path=\"*\" verb=\"*\" type=\"Microsoft.Owin.Host.SystemWeb.OwinHttpHandler\" />\r\n    </handlers>\r\n</system.webServer>\r\n```\r\n\r\nIf you want to customize index.html(or others) for authentication etc. You can use `ResolveCustomResource`.\r\n\r\n```csharp\r\napp.Map(\"/swagger\", builder =>\r\n{\r\n    builder.UseLightNodeSwagger(new LightNode.Swagger.SwaggerOptions(\"MySample\", \"/api\")\r\n    {\r\n        ResolveCustomResource = (filePath, loadedEmbeddedBytes) =>\r\n        {\r\n            if (filePath == \"index.html\")\r\n            {\r\n                using (var resourceStream = typeof(Startup).Assembly.GetManifestResourceStream(\"MySample.Swagger.index.html\"))\r\n                using (var ms = new MemoryStream())\r\n                {\r\n                    resourceStream.CopyTo(ms);\r\n                    return ms.ToArray();\r\n                }\r\n            }\r\n            return loadedEmbeddedBytes;\r\n        }\r\n    });\r\n});\r\n```\r\n\r\nwith ASP.NET MVC\r\n---\r\nYou can use LightNode with ASP.NET MVC. A simple solution is to change the root path.\r\n\r\n```csharp\r\npublic void Configuration(IAppBuilder app)\r\n{\r\n    app.Map(\"/api\",  x =>\r\n    {\r\n        x.UseLightNode();\r\n    });\r\n}\r\n```\r\n\r\nMore ContentFormatter\r\n---\r\nDefault content formatter is `JavaScriptContentFormatter`(application/json) and bundling formatters are `TextContentFormatter`(text/plain), `HtmlContentFormatter`(text/html), `RawOctetStreamContentFormatter`(application/octet-straem), `XmlContentFormatter`(application/xml), `DataContractContentFormatter`(application/xml), `DataContractJsonContentFormatter`(application/json).\r\n\r\nMore useful ContentFormatters(for JsonNet(JSON), Jil(JSON/JSON+GZip), Jil+LZ4, ProtoBuf, MsgPack) are available.\r\n\r\n* PM> Install-Package [LightNode.Formatter.JsonNet](https://nuget.org/packages/LightNode.Formatter.JsonNet/)\r\n* PM> Install-Package [LightNode.Formatter.Jil](https://nuget.org/packages/LightNode.Formatter.Jil/)\r\n* PM> Install-Package [LightNode.Formatter.Jil.LZ4](https://nuget.org/packages/LightNode.Formatter.Jil.LZ4/) \r\n* PM> Install-Package [LightNode.Formatter.ProtoBuf](https://nuget.org/packages/LightNode.Formatter.ProtoBuf/)\r\n* PM> Install-Package [LightNode.Formatter.MsgPack](https://nuget.org/packages/LightNode.Formatter.MsgPack/)\r\n\r\nConfiguration sample\r\n\r\n```csharp\r\npublic class Startup\r\n{\r\n    public void Configuration(Owin.IAppBuilder app)\r\n    {\r\n        // default is Json, If Accept-Encoding=gzip then Json+GZip\r\n        app.UseLightNode(new LightNodeOptions(AcceptVerbs.Get | AcceptVerbs.Post,\r\n            new JilContentFormatter(), new GZipJilContentFormatter()));\r\n    }\r\n}\r\n\r\npublic class Sample : LightNodeContract\r\n{\r\n    // use specified content formatter, select verb per operation\r\n    [OperationOption(AcceptVerbs.Get, typeof(HtmlContentFormatterFactory))]\r\n    public string Html()\r\n    {\r\n        return \"<html><body>aaa</body></html>\";\r\n    }\r\n    \r\n    // LightNode's default is GET | POST and default can customize.\r\n    // change per operation verb by OperationOption(AcceptVerbs)\r\n    // [Get/Post/Put/Delete/Patch]Attribute for its shortcut\r\n    [Post]\r\n    public int PostOnly()\r\n    {\r\n        return 0;\r\n    }\r\n}\r\n```\r\n\r\nReceive(or Send) byte[]\r\n---\r\nLightNode isn't allow byte[] argument. If you want to receive byte[] that use Base64 string instead of byte[]. But you needs to avoid Base64, you can take raw stream from `Environment`.\r\n\r\n```csharp\r\n[Post, IgnoreClientGenerate]\r\npublic int PostByte() // zero argument\r\n{\r\n    // Take raw stream\r\n    var body = this.Environment[\"owin.RequestBody\"] as Stream;\r\n    byte[] bodyBytes;\r\n    using (var ms = new MemoryStream())\r\n    {\r\n        body.CopyTo(ms);\r\n        bodyBytes = ms.ToArray();\r\n    }\r\n    return bodyBytes.Length;\r\n}\r\n```\r\n\r\nIf you want to receive `multipart/form-data`, you can parse by [ReadAsMultipartAsync](https://msdn.microsoft.com/ja-jp/library/hh944544.aspx) of `System.Net.Http.Formatting.dll`. \r\n\r\n```csharp\r\nvar body = this.Environment[\"owin.RequestBody\"] as Stream;\r\nvar multipart = await new StreamContent(body).ReadAsMultipartAsync();\r\n```\r\n\r\nIf you return byte[] array, you maybe should avoid Json(or other) ContentFormatter. You can use `RawOctetStreamContentFormatterFactory`.\r\n\r\n```csharp\r\n[IgnoreClientGenerate]\r\n[OperationOption(AcceptVerbs.Post, typeof(RawOctetStreamContentFormatterFactory))]\r\npublic byte[] EchoByte()\r\n{\r\n    var body = this.Environment[\"owin.RequestBody\"] as Stream;\r\n    byte[] bodyBytes;\r\n    using (var ms = new MemoryStream())\r\n    {\r\n        body.CopyTo(ms);\r\n        bodyBytes = ms.ToArray();\r\n    }\r\n    return bodyBytes;\r\n}\r\n```\r\n\r\nReturn HTML\r\n---\r\nIf you needs return html, set content formatter to `HtmlContentFormatter/HtmlContentFormatterFactory`. If you needs template engine, you can use [RazorEngine](https://github.com/Antaris/RazorEngine). Simple helper base contract.\r\n\r\n```csharp\r\npublic abstract class RazorContractBase : LightNode.Server.LightNodeContract\r\n{\r\n    static readonly IRazorEngineService razor = CreateRazorEngineService();\r\n\r\n    IRazorEngineService CreateRazorEngineService()\r\n    {\r\n        var config = new TemplateServiceConfiguration();\r\n        config.DisableTempFileLocking = true;\r\n        config.CachingProvider = new DefaultCachingProvider(_ => { });\r\n        config.TemplateManager = new DelegateTemplateManager(name =>\r\n        {\r\n            // import from \"Views\" directory\r\n            var viewPath = System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, \"Views\", name);\r\n            return System.IO.File.ReadAllText(viewPath);\r\n        });\r\n        return RazorEngineService.Create(config);\r\n    }\r\n\r\n    protected string View(string viewName)\r\n    {\r\n        return View(viewName, new object());\r\n    }\r\n\r\n    protected string View(string viewName, object model)\r\n    {\r\n        var type = model.GetType();\r\n        if (razor.IsTemplateCached(viewName, type))\r\n        {\r\n            return razor.Run(viewName, type, model);\r\n        }\r\n        else\r\n        {\r\n            return razor.RunCompile(viewName, type, model);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd you can make shortcut of OperationOptionAttribute.\r\n\r\n```\r\npublic class Html : LightNode.Server.OperationOptionAttribute\r\n{\r\n    public Html(AcceptVerbs acceptVerbs = AcceptVerbs.Get | AcceptVerbs.Post)\r\n        : base(acceptVerbs, typeof(HtmlContentFormatterFactory))\r\n    {\r\n\r\n    }\r\n}\r\n```\r\n\r\nLanguage Interoperability\r\n---\r\nLightNode is like RPC but REST. Public API follows a simple rule. Address is `{ClassName}/{MethodName}`, and it's case insensitive. GET parameter use QueryString. POST parameter use x-www-form-urlencoded. Response type follows configured ContentFormatter. Receiver can select response type use url extension(.xml, .json etc...) or Accept header.\r\n\r\nAuthentication, Session, Caching, Routing, Versioning, etc\r\n---\r\nYou can use other OWIN Middleware(for example [ASP.NET Identity](http://www.asp.net/identity)). LightNode can copmose with there. LightNode provides only core framework.\r\n\r\nLightNode can enable per assembly. For the versioning strategy with project separating.  \r\n\r\n```csharp\r\napp.Map(\"/v1\", x =>\r\n{\r\n    x.UseLightNode(new LightNodeOptions(), typeof(v1Contract).Assembly);\r\n});\r\n\r\napp.Map(\"/v2\", x =>\r\n{\r\n    x.UseLightNode(new LightNodeOptions(), typeof(v2Contract).Assembly);\r\n});\r\n```\r\n\r\nClient code generation\r\n--- \r\nClient side implementation of the REST API is often painful. LightNode solves by T4 code generation.\r\n\r\n```csharp\r\n// Open .tt file and configure four steps.\r\n\r\n<#@ assembly name=\"$(SolutionDir)\\Performance\\LightNode.Performance\\bin\\LightNode.Performance.dll\" #>\r\n<#\r\n    // ------------- T4 Configuration ------------- //\r\n    \r\n    // 1. Set LightNodeContract assemblies(and all dependency) path to above #@ assembly name # directive\r\n\r\n    // 2. Set Namespace & ClientName & Namespace\r\n    var clientName = \"LightNodeClient\";\r\n    var namespaceName = \"LightNode.Client\";\r\n\r\n    // 3. Set DefaultContentFormatter Construct String\r\n    var defaultContentFormatter = \"new LightNode.Formatter.JsonNetContentFormatter()\";\r\n\r\n    // 4. Set Additional using Namespace\r\n    var usingNamespaces = new [] {\"System.Linq\"};\r\n\r\n    // 5. Set append \"Async\" suffix to method name(ex: CalcAsync or Calc)\r\n    var addAsyncSuffix = true;\r\n\r\n    // ----------End T4 Configuration ------------- //\r\n```\r\n\r\n```csharp\r\n// generated code is like RPC Style.\r\n// {ClassName}.{MethodName}({Parameters}) \r\n\r\nvar client = new LightNodeClient(\"http://localhost\");\r\nawait client.Me.EchoAsync(\"test\");\r\nvar sum = await client.Me.SumAsync(1, 10, 100);\r\n```\r\n\r\nClient is very simple but very easy for use. Currently code generation provides for Portable Class Library(HttpClinet) and Unity3D(with [UniRx](https://github.com/neuecc/UniRx)).\r\n\r\nYou can download from NuGet. \r\n\r\n* PM> Install-Package [LightNode.Client.PCL.T4](https://nuget.org/packages/LightNode.Client.PCL.T4/)\r\n* PM> Install-Package [LightNode.Client.UniRx.T4](https://nuget.org/packages/LightNode.Client.UniRx.T4/)\r\n\r\nNote:Client generation currently supports POST only. \r\n\r\nDiagnostics\r\n---\r\nLightNode expose [LightNode.Diagnostics.LightNodeEventSource](https://github.com/neuecc/LightNode/blob/master/Source/LightNode.Server/Diagnostics/LightNodeEventSource.cs) for log diagnostics. It's using [Systen.Diagnostics.Tracing.EventSource](https://msdn.microsoft.com/ja-jp/library/system.diagnostics.tracing.eventsource.aspx), it's send to ETW(EventTrace for Windows) and you can subscribe easily by Microsoft's [Semantic Logging Application Block](https://github.com/mspnp/semantic-logging)\r\n Library.\r\n \r\nIf throws unhandled exception, LightNode's default no handles exception and pass thru other middleware. This option is useful for debugging with Glimpse or other diagnostics middleware such as Microsoft.Owin.Diagnostics's  UseErrorPage. You can also use LightNode's Builtin diagnostics system -  LightNodeOptions.ErrorHandlingPolicy `ErrorHandlingPolicy.ReturnInternalServerErrorIncludeErrorDetails`. It's show simply error string.\r\n\r\nIf LightNode can't create OperationContext(for example 404), default returns StatusCode and description string. This can customize `OperationMissingHandlingPolicy`, If `ThrowException` then throws `OperationNotFoundException`.\r\n\r\n```csharp\r\n// Default\r\nvar option = new LightNodeOptions()\r\n{\r\n    ErrorHandlingPolicy = ErrorHandlingPolicy.ThrowException,\r\n    OperationMissingHandlingPolicy = OperationMissingHandlingPolicy.ReturnErrorStatusCodeIncludeErrorDetails,\r\n};\r\napp.UseLightNode(option);\r\n```\r\n \r\nPerformance\r\n---\r\nLightNode is fastest framework.\r\n\r\n![lightnode_performance](https://f.cloud.github.com/assets/46207/1902439/a0a19c5c-7c72-11e3-9bea-244ac00dcd87.jpg)\r\n\r\nPerformance source code is in [LightNode/Performance](https://github.com/neuecc/LightNode/tree/master/Performance). Enviroment is \"Windows 8.1/CPU Core i7-3770K(3.5GHz)/Memory 32GB\" and disabled firewall and windows defender. Orange and Green bar is hosted on IIS(System.Web). LightNode(Green bar)'s performance is nearly raw handler. Gray bar is reference, LightNode on [Helios - Microsoft.Owin.Host.IIS](http://www.nuget.org/packages/Microsoft.Owin.Host.IIS/) gots extremely performance. \r\n\r\nBuild/Test Status\r\n---\r\n[![Build status](https://ci.appveyor.com/api/projects/status/i7smkb51sr0ghy15)](https://ci.appveyor.com/project/neuecc/lightnode)\r\n\r\nLightNode is using [AppVeyor](http://www.appveyor.com/) CI. You can check unit test status.\r\n\r\nReleaseNote\r\n---\r\n1.3.0 - 2015-04-28\r\n* Add ReturnStatusCodeException accepts object and contentFormatter\r\n* Add Swagger output Get/Post/Put/Patch/Delete\r\n* Fix Swagger can't generate when xml comment has method overload\r\n* Changed InjectCustomResource -> ResolveCustomResource\r\n* Docs Return html with RazorEngine tips\r\n\r\n1.2.1 - 2015-04-22\r\n* Fix LightNode.Server throws exception if run on SelfHost\r\n\r\n1.2.0 - 2015-04-19\r\n* Add LightNode.Swagger\r\n* Add LightNodeServerMiddleware.GetRegisteredHandlersInfo\r\n* Changed JilContentFormatter namespace \r\n* Fix UniRx.T4 LightNodeClient\r\n\r\n1.1.0 - 2015-02-21\r\n* Add AcceptVerbs.Put/Delete/Patch \r\n* Add HttpVerbAttributes([GET/POST/Put/Delete/Patch]Attribute)\r\n\r\n1.0.0 - 2015-02-16\r\n* Add Glimpse.LightNode\r\n* Add LightNode.Formatter.Jil\r\n* Add LightNode.Formatter.Jil.LZ4\r\n* Add LightNodeOptions.OperationCoordinatorFactory\r\n* ContentFormatter supports handling ContentEncoding\r\n* More LightNodeEventSource logging  \r\n\r\n0.4.0 - 2015-01-27\r\n* Add UniRx T4 Template\r\n* Add LightNodeEventSource logging\r\n* Add IgnoreClientGenerateAttribute\r\n* Add LightNodeOptions.OperationMissingHandlingPolicy\r\n* Add OperationOptionAttribute\r\n* Fix failed assembly load when depend assembly is not found\r\n* CodeGenerate ignore Abstract Contract\r\n* Improvement perforamnce\r\n\r\n0.3.0 - 2014-05-12\r\n* Add Unity T4 Template\r\n* Some fixes for PCL.T4 Template\r\n* Add default UseLightNode overload\r\n\r\n0.2.0 - 2014-01-14\r\n* Add Filter System\r\n* Enum Binding Performance Improvement\r\n* Strict parse for Enum\r\n* Parameter String disallows null at default\r\n* IContentFormatter needs Encoding\r\n* IContentFormatter.Ext can add multiple ext by \"|\" separater\r\n* Fixed T4 ClientCode generation\r\n* Return 204 when operation is void or Task\r\n* Return Arbitrary StatusCode that throws ReturnStatusCodeException\r\n* Add IgnoreOperationAttribute\r\n\r\n0.1.1 - 2013-12-23  \r\n* First Release\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}